import{_ as t,Y as c,Z as p,$ as a,a0 as s,a1 as e,a2 as o,E as l}from"./framework-e3f91821.js";const r={},i=o(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java" aria-hidden="true">#</a> Java</h1><blockquote><p>CharSequence和String<br> java的时间格式，以及与数据库交互建议格式<br> 反射与自定义注解<br> 代理-静态代理-动态代理<br> java接口可以多继承<br> JSR 是 Java Specification Requests 的缩写，意思是“Java 规范提案”</p></blockquote><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h2><ul><li>Class</li><li>Field</li><li>Constructor</li><li>Method</li></ul><h3 id="class" tabindex="-1"><a class="header-anchor" href="#class" aria-hidden="true">#</a> Class</h3><p>获取Class对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>

<span class="token comment">// 通过已有实例对象获取类的 Class 对象</span>
<span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 通过类的全限定名获取该类的 Class 对象</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.user&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个类的 Class 对象只有一个，也就是用上面三种方式获取的 Class 对象都是相同的。</p><h3 id="构造对象" tabindex="-1"><a class="header-anchor" href="#构造对象" aria-hidden="true">#</a> 构造对象</h3><h4 id="newinstance" tabindex="-1"><a class="header-anchor" href="#newinstance" aria-hidden="true">#</a> newInstance()</h4><p>通过 Class 类的 newInstance() 方法创建对象，该方法要求该 Class 对应类有<strong>public无参构造</strong>方法。执行 newInstance()方法实际上就是使用对应类的无参构造方法来创建该类的实例，其代码的作用等价于Super sup = new Super()。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Traget</span> target <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果 Super 类没有无参构造方法，运行程序时则会抛出一个 InstantiationException 实例化异常。</p><h4 id="实例化私有对象" tabindex="-1"><a class="header-anchor" href="#实例化私有对象" aria-hidden="true">#</a> 实例化私有对象</h4><ol><li>获取 Class 对象</li><li>通过 getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取到指定参数类型的构造方法</li><li>接下来调用 setAccessible(true) 绕过private修饰符检查</li><li>最后调用 newInstance() 传入相关参数，获取到类实例对象</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> constructor<span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 忽略访问检查</span>
constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user2 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">&quot;heihei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>getConstructor()和getDeclaredConstructor()区别：<br> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br> 这个方法会返回指定参数类型的所有构造器，包括public的和非public的，当然也包括private的。<br> getConstructor(Class&lt;?&gt;… parameterTypes)<br> 只返回指定参数且类型访问权限是public的构造器。</p></blockquote><p>？？？？ 每种功能内部以 Declared 细分：</p><p>有修饰的方法：可以获取该类内部包含的所有变量、方法和构造器，但是无法获取继承下来的信息</p><p>无修饰的方法：可以获取该类中修饰的变量、方法和构造器，可获取继承下来的信息</p><p>如果想获取类中**所有的（包括继承）**变量、方法和构造器，则需要同时调用和两个方法，用集合存储它们获得的变量、构造器和方法，以防两个方法获取到相同的东西。 ？？？？</p><h2 id="enum" tabindex="-1"><a class="header-anchor" href="#enum" aria-hidden="true">#</a> enum</h2><p>枚举与字符串常量</p><p>更加灵活的使用</p><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h2><p>元注解</p><p>自定义注解</p>`,27),u={href:"https://www.bilibili.com/read/cv13282317/",target:"_blank",rel:"noopener noreferrer"},d={href:"https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650238479&idx=1&sn=cef582b5c5a15853f391d013a0747a9d&chksm=88639f60bf1416761f9da62e7b59c0d2f892d1b6f6e85a809f963dca593cffdcb14a9e171ddb&scene=27",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.csdn.net/qq_22331931/article/details/106502625",target:"_blank",rel:"noopener noreferrer"},h=a("h2",{id:"异常",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#异常","aria-hidden":"true"},"#"),s(" 异常")],-1),v=a("p",null,"检查型异常 throws?",-1),b=a("p",null,"非检查型异常",-1);function m(f,g){const n=l("ExternalLinkIcon");return c(),p("div",null,[i,a("p",null,[a("a",u,[s("Java注解之自定义注解实现"),e(n)])]),a("p",null,[a("a",d,[s("一小时搞明白自定义注解(Annotation)"),e(n)])]),a("p",null,[a("a",k,[s("aop实现自定义注解"),e(n)])]),h,v,b])}const C=t(r,[["render",m],["__file","Java.html.vue"]]);export{C as default};
